package lecture15absTypes;

class Book {
  String title;
  String author;
  int price;
  
  Book(String title, String author, int price) {
    this.title = title;
    this.author = author;
    this.price = price;
  }
}

class Runner {
  String name;
  int age;
  int bib;          // bib number
  boolean isMale;
  int pos;          // starting position
  int time;         // in min

  Runner(String name, int age, int bib, boolean isMale, int pos, int time) {
    this.name = name;
    this.age = age;
    this.bib = bib;
    this.isMale = isMale;
    this.pos = pos;
    this.time = time;
  }
}

interface IPred<T> {
  boolean apply(T t);
}

class BookByAuthor implements IPred<Book> {

  public boolean apply(Book b) {
    return false;
  }
  
}

interface IComparator<T> {
  int compare(T t1, T t2);
}

// U can't be int, double, or boolean (primitive types)
// Java only permits class/interface types as the type parameters to generics
// use <Integer>, <Double>, <Boolean> instead (just "wrappers" for primitives)
interface IList<T> {
  IList<T> filter(IPred<T> pred);
  IList<T> sort(IComparator<T> comp);
  IList<T> insert(IComparator<T> comp, T t);
  int length();
  
  // map; apply function f to all the elements
  // “In IList<T>, map is a method parameterized by U, that takes a function from T values to U values,
  // and produces an IList<U> as a result.”
  <U> IList<U> map(IFunc<T, U> f);
}

// “An MtList of T is a list of T.” 
class MtList<T> implements IList<T> {
  
  public IList<T> filter(IPred<T> pred) {
    return this;
  }

  public IList<T> sort(IComparator<T> comp) {
    return this;
  }

  public IList<T> insert(IComparator<T> comp, T t) {
    return new ConsList<T>(t, this);
  }

  public int length() {
    return 0;
  }

  public <U> IList<U> map(IFunc<T, U> f) {
    return new MtList<U>();
  }

}

class ConsList<T> implements IList<T> {
  T first;
  IList<T> rest;
  
  ConsList(T first, IList<T> rest) {
    this.first = first;
    this.rest = rest;
  }
  
  public IList<T> filter(IPred<T> pred) {
    if (pred.apply(this.first)) {
      return new ConsList<T>(this.first, this.rest.filter(pred));
    }
    return this.rest.filter(pred);
  }

  public IList<T> sort(IComparator<T> comp) {
    return this.rest.sort(comp).insert(comp, this.first);
  }

  public IList<T> insert(IComparator<T> comp, T t) {
    if (comp.compare(t, this.first) < 0) {
      return new ConsList<T>(t, this);
    }
    return new ConsList<T>(this.first, this.rest.insert(comp, t));
  }

  public int length() {
    return 1 + this.length();
  }

  public <U> IList<U> map(IFunc<T, U> f) {
    return new ConsList<U>(f.apply(this.first), this.rest.map(f));
  }
}

// generic in TWO type parameters
interface IFunc<A, R> {
  R apply(A arg);
}

class RunnerName implements IFunc<Runner, String> {
  public String apply(Runner r) {
    return r.name;
  }
}

class CirclePerimeter implements IFunc<Circle, Double> {
  public Double apply(Circle c) {
    return 2.0 * Math.PI * c.radius;
  }
}

class Circle {
  int radius;
  
  Circle(int radius) {
    this.radius = radius;
  }
}


class ExamplesIList {
  
  IList<Circle> circs = new ConsList<Circle>(new Circle(3), new MtList<Circle>());
  IList<Double> circPerims = circs.map(new CirclePerimeter());
  
}